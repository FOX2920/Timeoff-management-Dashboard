import streamlit as st
import requests
import pandas as pd
from datetime import datetime, timedelta
import json
import numpy as np
from typing import Dict, List, Optional
import plotly.express as px
import plotly.graph_objects as go
from streamlit_calendar import calendar
import os
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import re
import unicodedata
import pytz

# C·∫•u h√¨nh page
st.set_page_config(
    page_title="Time Off Dashboard", 
    page_icon="üèñÔ∏è", 
    layout="wide",
    initial_sidebar_state="expanded"
)

class ReasonClassifier:
    """Class ƒë·ªÉ ph√¢n lo·∫°i l√Ω do ngh·ªâ b·∫±ng cosine similarity"""
    
    def __init__(self):
        # ƒê·ªãnh nghƒ©a categories v√† t·ª´ kh√≥a ƒë·∫°i di·ªán theo y√™u c·∫ßu m·ªõi
        self.categories = {
            'annual_leave': {
                'keywords': [
                    'ph√©p nƒÉm', 'ngh·ªâ ph√©p', 'annual leave', 'vacation', 'holiday',
                    'du l·ªãch', 'ƒëi ch∆°i', 'ngh·ªâ m√°t', 'resort', 'bi·ªÉn', 'n√∫i',
                    'v·ªÅ qu√™', 'thƒÉm qu√™', 'ngh·ªâ d∆∞·ª°ng', 'th∆∞ gi√£n', 'relax',
                    'break', 'ngh·ªâ ng∆°i', 'rest', 'ph·ª•c h·ªìi', 't√°i t·∫°o nƒÉng l∆∞·ª£ng',
                    'ƒëi du l·ªãch', 'travel', 'trip', 'picnic', 'tour', 'kh√°m ph√°',
                    'ngh·ªâ l·ªÖ', 'long weekend', 'ngh·ªâ cu·ªëi tu·∫ßn', 'staycation'
                ],
                'color': '#28a745',  # Xanh l√°
                'icon': 'üèñÔ∏è',
                'label': 'Ph√©p nƒÉm'
            },
            'personal': {
                'keywords': [
                    'c√° nh√¢n', 'vi·ªác ri√™ng', 'b·∫≠n vi·ªác c√° nh√¢n', 'c√¥ng vi·ªác c√° nh√¢n',
                    'gi·∫£i quy·∫øt vi·ªác', 'l√†m vi·ªác c√° nh√¢n', 'vi·ªác t∆∞', 't·ª± do',
                    'mua s·∫Øm', 'ƒëi ng√¢n h√†ng', 'l√†m gi·∫•y t·ªù', 'visa', 'h·ªô chi·∫øu',
                    's·ª≠a nh√†', 'chuy·ªÉn nh√†', 'd·ªçn nh√†', 'vi·ªác nh√†'
                ],
                'color': '#6f42c1',  # T√≠m
                'icon': 'üë§',
                'label': 'C√° nh√¢n'
            },
            'remote': {
                'keywords': [
                    'remote', 'work from home', 'wfh', 'l√†m vi·ªác t·ª´ xa','outside',
                    'l√†m vi·ªác t·∫°i nh√†', 'online', 't·ª´ xa', 'kh√¥ng ƒë·∫øn c√¥ng ty',
                    '·ªü nh√† l√†m vi·ªác', 'home office', 'telecommuting', 'virtual work'
                ],
                'color': '#17a2b8',  # Xanh d∆∞∆°ng nh·∫°t
                'icon': 'üíª',
                'label': 'Remote'
            },
            'business': {
                'keywords': [
                    'c√¥ng t√°c', 'business trip', 'c√¥ng vi·ªác', 'meeting', 'h·ªçp',
                    'h·ªôi ngh·ªã', 'ƒë√†o t·∫°o', 'kh√≥a h·ªçc', 'seminar', 'conference',
                    'g·∫∑p kh√°ch h√†ng', 'partner', 'ƒë·ªëi t√°c', 'd·ª± √°n', 'project',
                    'ra ngo√†i c√¥ng t√°c', 'ƒëi c√¥ng t√°c', 'business'
                ],
                'color': '#fd7e14',  # Cam
                'icon': 'üíº',
                'label': 'C√¥ng t√°c'
            },
            'sick': {
                'keywords': [
                    '·ªëm', 'b·ªánh', 'ƒëau', 's·ªët', 'c·∫£m', 'ho', 'kh√°m b·ªánh', 'ch·ªØa b·ªánh',
                    'b√°c sƒ©', 'b·ªánh vi·ªán', 'ph√≤ng kh√°m', 'ƒëi·ªÅu tr·ªã', 'thu·ªëc', 'y t·∫ø',
                    's·ª©c kh·ªèe', 'kh√¥ng kh·ªèe', 'm·ªát', 'ki·ªát s·ª©c', 'stress', 'lo √¢u',
                    'sick', 'ill', 'medical', 'doctor', 'hospital', 'fever', 'cold',
                    'ƒëau ƒë·∫ßu', 'ƒëau b·ª•ng', 'ƒëau rƒÉng', 'c√∫m', 'vi√™m h·ªçng', 'ho khan',
                    's·ªët cao', 's·ªët nh·∫π', 'c·∫£m l·∫°nh', 'c·∫£m c√∫m', 'kh√¥ng ƒë∆∞·ª£c kh·ªèe',
                    'ƒëi kh√°m', 't√°i kh√°m', 'x√©t nghi·ªám', 'ch·ª•p phim', 'si√™u √¢m'
                ],
                'color': '#dc3545',  # ƒê·ªè
                'icon': 'ü§í',
                'label': 'ƒêau ·ªëm'
            },
            'special_leave': {
                'keywords': [
                    'thai s·∫£n', 'sinh con', 'maternity', 'paternity', 'ƒë√°m c∆∞·ªõi', 'c∆∞·ªõi',
                    'wedding', 'ƒë√°m tang', 'tang l·ªÖ', 'funeral', 'ma chay', 'hi·∫øu h·ª∑',
                    'gia ƒë√¨nh', 'b·ªë', 'm·∫π', 'con', 'v·ª£', 'ch·ªìng', '√¥ng', 'b√†', 'ch√°u',
                    'h·ªçp m·∫∑t gia ƒë√¨nh', 'vi·ªác gia ƒë√¨nh', 'chƒÉm s√≥c', 'ng∆∞·ªùi th√¢n',
                    'kh·∫©n c·∫•p', 'g·∫•p', 'emergency', 'c·ª©u c·∫•p', 'tai n·∫°n', 's·ª± c·ªë',
                    'b·∫•t ng·ªù', 'ƒë·ªôt xu·∫•t'
                ],
                'color': '#e83e8c',  # H·ªìng
                'icon': 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶',
                'label': 'Ch·∫ø ƒë·ªô ƒë·∫∑c bi·ªát'
            }
        }
        
        # T·∫°o corpus t·ª´ keywords
        self.corpus = []
        self.category_names = []
        
        for category, data in self.categories.items():
            combined_text = ' '.join(data['keywords'])
            self.corpus.append(combined_text)
            self.category_names.append(category)
        
        # Kh·ªüi t·∫°o TF-IDF vectorizer
        self.vectorizer = TfidfVectorizer(
            ngram_range=(1, 2),
            stop_words=None,
            lowercase=True,
            max_features=1000
        )
        
        # Fit vectorizer v·ªõi corpus
        self.category_vectors = self.vectorizer.fit_transform(self.corpus)
    
    def preprocess_text(self, text: str) -> str:
        """Ti·ªÅn x·ª≠ l√Ω text"""
        if not text or pd.isna(text):
            return ""
        
        # Chuy·ªÉn v·ªÅ lowercase
        text = str(text).lower()
        
        # Lo·∫°i b·ªè d·∫•u c√¢u v√† k√Ω t·ª± ƒë·∫∑c bi·ªát
        text = re.sub(r'[^\w\s]', ' ', text)
        
        # Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a
        text = re.sub(r'\s+', ' ', text).strip()
        
        return text
    
    def classify_reason(self, reason: str, threshold: float = 0.15) -> Dict:
        """
        Ph√¢n lo·∫°i l√Ω do ngh·ªâ b·∫±ng cosine similarity v·ªõi rule-based fallback
        
        Args:
            reason: L√Ω do ngh·ªâ
            threshold: Ng∆∞·ª°ng similarity t·ªëi thi·ªÉu
            
        Returns:
            Dict ch·ª©a th√¥ng tin category
        """
        if not reason or pd.isna(reason):
            return self.get_default_category()
        
        # Ti·ªÅn x·ª≠ l√Ω text
        processed_reason = self.preprocess_text(reason)
        
        if not processed_reason:
            return self.get_default_category()
        
        # Rule-based classification tr∆∞·ªõc (cho c√°c tr∆∞·ªùng h·ª£p r√µ r√†ng)
        rule_based_result = self._rule_based_classify(processed_reason)
        if rule_based_result:
            return rule_based_result
        
        try:
            # Vector h√≥a reason
            reason_vector = self.vectorizer.transform([processed_reason])
            
            # T√≠nh cosine similarity v·ªõi t·∫•t c·∫£ categories
            similarities = cosine_similarity(reason_vector, self.category_vectors)[0]
            
            # T√¨m category c√≥ similarity cao nh·∫•t
            max_similarity_idx = np.argmax(similarities)
            max_similarity = similarities[max_similarity_idx]
            
            # Ki·ªÉm tra threshold
            if max_similarity >= threshold:
                best_category = self.category_names[max_similarity_idx]
                category_info = self.categories[best_category].copy()
                category_info['similarity'] = max_similarity
                category_info['category'] = best_category
                return category_info
            else:
                return self.get_default_category()
                
        except Exception as e:
            print(f"Error in classify_reason: {e}")
            return self.get_default_category()
    
    def _rule_based_classify(self, processed_reason: str) -> Optional[Dict]:
        """
        Rule-based classification cho c√°c tr∆∞·ªùng h·ª£p r√µ r√†ng
        
        Args:
            processed_reason: L√Ω do ƒë√£ ƒë∆∞·ª£c ti·ªÅn x·ª≠ l√Ω
            
        Returns:
            Dict ch·ª©a th√¥ng tin category n·∫øu match, None n·∫øu kh√¥ng
        """
        # Sick leave patterns (∆∞u ti√™n cao nh·∫•t)
        sick_patterns = [
            r'\b(·ªëm|b·ªánh|ƒëau|s·ªët|ho|c·∫£m|kh√¥ng kh·ªèe|sick|ill|fever)\b',
            r'\b(kh√°m b·ªánh|ch·ªØa b·ªánh|b√°c sƒ©|b·ªánh vi·ªán|ph√≤ng kh√°m|doctor|hospital)\b',
            r'\b(thu·ªëc|ƒëi·ªÅu tr·ªã|y t·∫ø|s·ª©c kh·ªèe|medical)\b'
        ]
        
        for pattern in sick_patterns:
            if re.search(pattern, processed_reason, re.IGNORECASE):
                sick_info = self.categories['sick'].copy()
                sick_info['similarity'] = 0.95  # High confidence for rule-based
                sick_info['category'] = 'sick'
                return sick_info
        
        # Remote work patterns
        remote_patterns = [
            r'\b(remote|wfh|work from home|l√†m vi·ªác t·∫°i nh√†|l√†m vi·ªác t·ª´ xa)\b',
            r'\b(·ªü nh√† l√†m vi·ªác|kh√¥ng ƒë·∫øn c√¥ng ty|home office)\b'
        ]
        
        for pattern in remote_patterns:
            if re.search(pattern, processed_reason, re.IGNORECASE):
                remote_info = self.categories['remote'].copy()
                remote_info['similarity'] = 0.90
                remote_info['category'] = 'remote'
                return remote_info
        
        # Business trip patterns
        business_patterns = [
            r'\b(c√¥ng t√°c|business trip|meeting|h·ªçp|h·ªôi ngh·ªã)\b',
            r'\b(g·∫∑p kh√°ch h√†ng|partner|ƒë·ªëi t√°c|conference)\b',
            r'\b(ra ngo√†i c√¥ng t√°c|ƒëi c√¥ng t√°c)\b'
        ]
        
        for pattern in business_patterns:
            if re.search(pattern, processed_reason, re.IGNORECASE):
                business_info = self.categories['business'].copy()
                business_info['similarity'] = 0.88
                business_info['category'] = 'business'
                return business_info
        
        return None
    
    def get_default_category(self) -> Dict:
        """Tr·∫£ v·ªÅ category m·∫∑c ƒë·ªãnh"""
        return {
            'color': '#6c757d',  # X√°m
            'icon': 'üìù',
            'label': 'Kh√°c',
            'category': 'other',
            'similarity': 0.0
        }
    
    def get_category_distribution(self, reasons: List[str]) -> Dict:
        """Ph√¢n t√≠ch ph√¢n b·ªë categories t·ª´ danh s√°ch reasons"""
        distribution = {}
        
        for reason in reasons:
            if pd.notna(reason) and str(reason).strip():
                result = self.classify_reason(str(reason))
                category = result['category']
                
                if category not in distribution:
                    distribution[category] = {
                        'count': 0,
                        'reasons': [],
                        'color': result['color'],
                        'label': result['label'],
                        'icon': result['icon']
                    }
                
                distribution[category]['count'] += 1
                distribution[category]['reasons'].append(reason)
        
        return distribution

class EmployeeManager:
    """Class ƒë·ªÉ qu·∫£n l√Ω th√¥ng tin nh√¢n vi√™n v√† mapping username -> name"""
    
    def __init__(self, account_token: str):
        self.account_token = account_token
        self.request_timeout = 30
        self.username_to_name_map = {}
        self._load_employee_mapping()
    
    def _make_request(self, url: str, data: Dict, description: str = "") -> requests.Response:
        """Th·ª±c hi·ªán HTTP request v·ªõi error handling"""
        try:
            response = requests.post(url, data=data, timeout=self.request_timeout)
            response.raise_for_status()
            return response
        except requests.exceptions.RequestException as e:
            st.error(f"Error {description}: {e}")
            raise
    
    def _load_employee_mapping(self):
        """T·∫£i mapping username -> name t·ª´ account API"""
        url = "https://account.base.vn/extapi/v1/group/get"
        data = {"access_token": self.account_token, "path": "aplus"}
        
        try:
            response = self._make_request(url, data, "fetching account members")
            response_data = response.json()
            
            members = response_data.get('group', {}).get('members', [])
            
            # T·∫°o mapping username -> name
            self.username_to_name_map = {
                m.get('username', ''): m.get('name', '') 
                for m in members 
                if m.get('username') and m.get('name')
            }
            
        except Exception as e:
            st.error(f"L·ªói khi l·∫•y danh s√°ch nh√¢n vi√™n: {e}")
            self.username_to_name_map = {}
    
    def get_name_by_username(self, username: str) -> str:
        """L·∫•y name t·ª´ username, fallback v·ªÅ username n·∫øu kh√¥ng t√¨m th·∫•y"""
        if not username:
            return ''
        return self.username_to_name_map.get(username, username)

class TimeoffProcessor:
    """Class ƒë·ªÉ x·ª≠ l√Ω d·ªØ li·ªáu timeoff v√† thay th·∫ø username b·∫±ng name"""
    
    def __init__(self, timeoff_token: str, account_token: str):
        self.timeoff_token = timeoff_token
        self.employee_manager = EmployeeManager(account_token)
        
    def get_base_timeoff_data(self):
        """L·∫•y d·ªØ li·ªáu t·ª´ Base Timeoff API"""
        url = "https://timeoff.base.vn/extapi/v1/timeoff/list"
        
        payload = f'access_token={self.timeoff_token}'
        headers = {'Content-Type': 'application/x-www-form-urlencoded'}
        
        response = requests.post(url, headers=headers, data=payload)
        return response.json()
    
    def extract_form_data(self, form_list):
        """Extract d·ªØ li·ªáu t·ª´ form fields"""
        form_data = {}
        for form_item in form_list:
            if form_item.get('name') and form_item.get('value'):
                form_data[form_item['name']] = form_item['value']
        return form_data
    
    def extract_shift_values(self, shifts_data):
        """Extract shift values t·ª´ shifts data v√† tr·∫£ v·ªÅ list"""
        shift_values = []
        
        if not shifts_data or not isinstance(shifts_data, list):
            return shift_values
        
        for shift_day in shifts_data:
            shifts = shift_day.get('shifts', [])
            for shift in shifts:
                if shift.get('value'):
                    shift_values.append(shift['value'])
        
        return shift_values
    
    def clean_vietnamese_text(self, text):
        """Clean Vietnamese text for column names"""
        text = unicodedata.normalize('NFD', text)
        text = ''.join(char for char in text if unicodedata.category(char) != 'Mn')
        text = text.replace(' ', '_').replace('/', '_').replace('(', '').replace(')', '').replace('-', '_').lower()
        return text
    
    def convert_timestamp_to_date(self, timestamp):
        """Chuy·ªÉn timestamp th√†nh datetime v·ªõi timezone ch√≠nh x√°c"""
        if timestamp and timestamp != '0':
            try:
                # S·ª≠ d·ª•ng timezone Asia/Ho_Chi_Minh ƒë·ªÉ tr√°nh l·ªách m√∫i gi·ªù
                utc_dt = datetime.fromtimestamp(int(timestamp), tz=pytz.UTC)
                vietnam_tz = pytz.timezone('Asia/Ho_Chi_Minh')
                return utc_dt.astimezone(vietnam_tz)
            except:
                return None
        return None
    
    def convert_approvals_to_names(self, approvals: List[str]) -> str:
        """Chuy·ªÉn ƒë·ªïi danh s√°ch approval usernames th√†nh names"""
        if not approvals:
            return ''
        
        approval_names = []
        for username in approvals:
            name = self.employee_manager.get_name_by_username(username)
            approval_names.append(name)
        
        return ', '.join(approval_names)
    
    def create_ly_do_column_and_cleanup(self, df):
        """T·∫°o c·ªôt 'ly_do' t·ª´ c√°c c·ªôt c√≥ s·∫µn theo th·ª© t·ª± ∆∞u ti√™n"""
        if df.empty:
            return df
            
        df_copy = df.copy()
        df_copy['ly_do'] = ''
        
        priority_columns = ['ly_do_xin_nghi_phep', 'ly_do_xin_nghi_chinh', 'ly_do_xin_nghi']
        
        for col in priority_columns:
            if col in df_copy.columns:
                mask = (
                    (df_copy['ly_do'] == '') & 
                    (df_copy[col].notna()) & 
                    (df_copy[col].astype(str).str.strip() != '')
                )
                df_copy.loc[mask, 'ly_do'] = df_copy.loc[mask, col].astype(str).str.strip()
        
        # Special case: n·∫øu metatype l√† business v√† ly_do v·∫´n r·ªóng, ƒë·∫∑t ly_do = "business"
        business_mask = (
            (df_copy['ly_do'] == '') & 
            (df_copy['metatype'] == 'business')
        )
        df_copy.loc[business_mask, 'ly_do'] = 'business'

        # Special case: n·∫øu metatype l√† outside v√† ly_do v·∫´n r·ªóng, ƒë·∫∑t ly_do = "outside"
        outside_mask = (
            (df_copy['ly_do'] == '') & 
            (df_copy['metatype'] == 'outside')
        )
        df_copy.loc[outside_mask, 'ly_do'] = 'remote'
        
        columns_to_drop = [col for col in priority_columns if col in df_copy.columns]
        if columns_to_drop:
            df_copy = df_copy.drop(columns=columns_to_drop)
        
        return df_copy
    
    def extract_timeoff_to_dataframe(self, api_response):
        """Extract c√°c tr∆∞·ªùng quan tr·ªçng t·ª´ Base Timeoff API response th√†nh DataFrame v·ªõi name mapping"""
        timeoffs_data = []
        
        if 'timeoffs' in api_response:
            for timeoff in api_response['timeoffs']:
                form_data = self.extract_form_data(timeoff.get('form', []))
                
                approvals = timeoff.get('approvals', [])
                approval_names = self.convert_approvals_to_names(approvals)
                
                total_shifts = len(timeoff.get('shifts', []))
                
                total_leave_days = 0
                for shift_day in timeoff.get('shifts', []):
                    for shift in shift_day.get('shifts', []):
                        if 'num_leave' in shift:
                            total_leave_days += float(shift.get('num_leave', 0))
                
                final_approver_username = ''
                final_approver_name = ''
                if timeoff.get('data', {}).get('final_approved'):
                    final_approver_username = timeoff['data']['final_approved'].get('username', '')
                    final_approver_name = self.employee_manager.get_name_by_username(final_approver_username)
                
                username = timeoff.get('username', '')
                employee_name = self.employee_manager.get_name_by_username(username)
                
                # Chuy·ªÉn ƒë·ªïi timestamp th√†nh datetime v·ªõi timezone ch√≠nh x√°c
                start_date = self.convert_timestamp_to_date(timeoff.get('start_date'))
                end_date = self.convert_timestamp_to_date(timeoff.get('end_date'))
                
                # Extract buoi_nghi t·ª´ shifts data
                buoi_nghi = self.extract_shift_values(timeoff.get('shifts', []))
                
                timeoff_record = {
                    'id': timeoff.get('id'),
                    'employee_name': employee_name,
                    'username': username,
                    'state': timeoff.get('state'),
                    'metatype': timeoff.get('metatype'),
                    'paid_timeoff': timeoff.get('paid_timeoff'),
                    'start_date': start_date,
                    'end_date': end_date,
                    'total_leave_days': total_leave_days,
                    'total_shifts': total_shifts,
                    'buoi_nghi': buoi_nghi,
                    'approvals': approval_names,
                    'final_approver': final_approver_name,
                    'workflow': timeoff.get('workflow'),
                    'created_time': self.convert_timestamp_to_date(timeoff.get('since')),
                    'last_update': self.convert_timestamp_to_date(timeoff.get('last_update')),
                }
                
                # Add form data fields
                column_mapping = {
                    'L√Ω do xin ngh·ªâ ph√©p': 'ly_do_xin_nghi_phep',
                    'L√Ω do xin ngh·ªâ': 'ly_do_xin_nghi',  
                    'L√Ω do': 'ly_do_xin_nghi',
                    'Ghi ch√∫': 'ghi_chu',
                    'L√Ω do c√° nh√¢n': 'ly_do_ca_nhan',
                    'B·∫≠n vi·ªác c√° nh√¢n': 'ban_viec_ca_nhan',
                    'Vi·ªác ri√™ng': 'viec_rieng'
                }
                
                for key, value in form_data.items():
                    if key in column_mapping:
                        clean_key = column_mapping[key]
                    else:
                        clean_key = self.clean_vietnamese_text(key)
                    timeoff_record[clean_key] = value
                
                timeoff_record['ly_do_xin_nghi_chinh'] = (
                    form_data.get('L√Ω do xin ngh·ªâ ph√©p', '') or 
                    form_data.get('L√Ω do xin ngh·ªâ', '') or
                    form_data.get('L√Ω do', '') or
                    form_data.get('L√Ω do c√° nh√¢n', '') or
                    form_data.get('B·∫≠n vi·ªác c√° nh√¢n', '') or
                    form_data.get('Vi·ªác ri√™ng', '')
                )
                
                timeoffs_data.append(timeoff_record)
        
        df = pd.DataFrame(timeoffs_data)
        
        if not df.empty and 'created_time' in df.columns:
            df = df.sort_values('created_time', ascending=False)
        
        df = self.create_ly_do_column_and_cleanup(df)
        
        return df
    
    def get_shift_time_range(self, buoi_nghi_list):
        """Ph√¢n t√≠ch bu·ªïi ngh·ªâ v√† tr·∫£ v·ªÅ th√¥ng tin th·ªùi gian - UPGRADED VERSION"""
        if not buoi_nghi_list or not isinstance(buoi_nghi_list, list):
            return {'is_all_day': True, 'start_time': None, 'end_time': None}

        if len(buoi_nghi_list) >= 2:
            # N·∫øu ngh·ªâ c·∫£ ng√†y (c·∫£ 2 bu·ªïi), tr·∫£ v·ªÅ danh s√°ch 2 s·ª± ki·ªán
            return {
                'is_all_day': True,
                'shift_events': [
                    {'start_time': '08:00:00', 'end_time': '12:00:00'},
                    {'start_time': '13:00:00', 'end_time': '17:30:00'}
                ]
            }

        if len(buoi_nghi_list) == 1:
            shift = buoi_nghi_list[0]
            shift_time_mapping = {
                '8:00-12:00': {'start_time': '08:00:00', 'end_time': '12:00:00'},
                '13:00-17:30': {'start_time': '13:00:00', 'end_time': '17:30:00'}
            }

            if shift in shift_time_mapping:
                time_info = shift_time_mapping[shift]
                return {
                    'is_all_day': False,
                    'start_time': time_info['start_time'],
                    'end_time': time_info['end_time']
                }

        return {'is_all_day': True, 'start_time': None, 'end_time': None}
    
    def process_and_structure_timeoff(self, row: pd.Series, classifier: ReasonClassifier) -> Optional[List[Dict]]:
        """
        X·ª≠ l√Ω chi ti·∫øt m·ªôt y√™u c·∫ßu ngh·ªâ v√† tr·∫£ v·ªÅ m·ªôt list c√°c b·∫£n ghi ƒë√£ ƒë∆∞·ª£c c·∫•u tr√∫c
        UPGRADED: X·ª≠ l√Ω ngh·ªâ nhi·ªÅu ng√†y v√† t·∫°o nhi·ªÅu events cho m·ªói bu·ªïi
        """
        if pd.isna(row['start_date']) or pd.isna(row['end_date']):
            return None

        # Ph√¢n lo·∫°i l√Ω do
        reason_result = classifier.classify_reason(str(row['ly_do'])) if row['ly_do'] and str(row['ly_do']).strip() else classifier.get_default_category()

        # T·∫°o ti√™u ƒë·ªÅ c∆° b·∫£n
        base_title = f"{reason_result['icon']} {row['employee_name']}"
        if row['ly_do'] and row['ly_do'] != '':
            reason_short = row['ly_do'][:50] + "..." if len(row['ly_do']) > 50 else row['ly_do']
            base_title += f" - {reason_short}"
        base_title += f" ({reason_result['label']})"

        # X·ª≠ l√Ω th·ªùi gian
        buoi_nghi = row.get('buoi_nghi', [])
        time_info = self.get_shift_time_range(buoi_nghi)

        start_date = row['start_date'].date()
        end_date = row['end_date'].date()
        num_days = (end_date - start_date).days + 1

        processed_leaves = []

        # T·∫°o events cho t·ª´ng ng√†y
        for day_offset in range(num_days):
            current_date = start_date + timedelta(days=day_offset)
            day_label = f"Ng√†y {day_offset + 1}/{num_days}" if num_days > 1 else ""
            
            if time_info.get('shift_events'):
                # Ngh·ªâ c·∫£ ng√†y - t·∫°o 2 b·∫£n ghi cho s√°ng v√† chi·ªÅu
                for i, shift_time in enumerate(time_info['shift_events']):
                    shift_label = "S√°ng" if i == 0 else "Chi·ªÅu"
                    title_with_day = f"{base_title}"
                    if day_label:
                        title_with_day += f" - {day_label} - {shift_label}"
                    
                    processed_leaves.append({
                        'title': title_with_day,
                        'start': f"{current_date.strftime('%Y-%m-%d')}T{shift_time['start_time']}",
                        'end': f"{current_date.strftime('%Y-%m-%d')}T{shift_time['end_time']}",
                        'color': reason_result['color'],
                        'borderColor': reason_result['color'],
                        'textColor': '#ffffff',
                        'allDay': False,
                        'extendedProps': {
                            'id': row['id'],
                            'employee': row['employee_name'],
                            'state': row['state'],
                            'metatype': row['metatype'],
                            'days': row['total_leave_days'],
                            'reason': row['ly_do'],
                            'buoi_nghi': buoi_nghi,
                            'approver': row['final_approver'],
                            'created_time': row['created_time'].strftime('%Y-%m-%d %H:%M') if pd.notna(row['created_time']) else 'N/A',
                            'last_update': row['last_update'].strftime('%Y-%m-%d %H:%M') if pd.notna(row['last_update']) else 'N/A',
                            'paid': row['paid_timeoff'] if 'paid_timeoff' in row else False,
                            'classification': reason_result['label'],
                            'similarity_score': reason_result.get('similarity', 0),
                            'day_info': day_label,
                            'shift_info': shift_label
                        },
                        'display': 'block'
                    })
            elif time_info['is_all_day']:
                # Ngh·ªâ c·∫£ ng√†y - t·∫°o 1 b·∫£n ghi all-day
                title_with_day = f"{base_title}"
                if day_label:
                    title_with_day += f" - {day_label}"
                    
                processed_leaves.append({
                    'title': title_with_day,
                    'start': current_date.strftime('%Y-%m-%d'),
                    'end': (current_date + timedelta(days=1)).strftime('%Y-%m-%d'),
                    'color': reason_result['color'],
                    'borderColor': reason_result['color'],
                    'textColor': '#ffffff',
                    'allDay': True,
                    'extendedProps': {
                        'id': row['id'],
                        'employee': row['employee_name'],
                        'state': row['state'],
                        'metatype': row['metatype'],
                        'days': row['total_leave_days'],
                        'reason': row['ly_do'],
                        'buoi_nghi': buoi_nghi,
                        'approver': row['final_approver'],
                        'created_time': row['created_time'].strftime('%Y-%m-%d %H:%M') if pd.notna(row['created_time']) else 'N/A',
                        'last_update': row['last_update'].strftime('%Y-%m-%d %H:%M') if pd.notna(row['last_update']) else 'N/A',
                        'paid': row['paid_timeoff'] if 'paid_timeoff' in row else False,
                        'classification': reason_result['label'],
                        'similarity_score': reason_result.get('similarity', 0),
                        'day_info': day_label
                    },
                    'display': 'block'
                })
            else:
                # Ngh·ªâ m·ªôt bu·ªïi c·ª• th·ªÉ
                title_with_day = f"{base_title}"
                if day_label:
                    title_with_day += f" - {day_label}"
                    
                processed_leaves.append({
                    'title': title_with_day,
                    'start': f"{current_date.strftime('%Y-%m-%d')}T{time_info['start_time']}",
                    'end': f"{current_date.strftime('%Y-%m-%d')}T{time_info['end_time']}",
                    'color': reason_result['color'],
                    'borderColor': reason_result['color'],
                    'textColor': '#ffffff',
                    'allDay': False,
                    'extendedProps': {
                        'id': row['id'],
                        'employee': row['employee_name'],
                        'state': row['state'],
                        'metatype': row['metatype'],
                        'days': row['total_leave_days'],
                        'reason': row['ly_do'],
                        'buoi_nghi': buoi_nghi,
                        'approver': row['final_approver'],
                        'created_time': row['created_time'].strftime('%Y-%m-%d %H:%M') if pd.notna(row['created_time']) else 'N/A',
                        'last_update': row['last_update'].strftime('%Y-%m-%d %H:%M') if pd.notna(row['last_update']) else 'N/A',
                        'paid': row['paid_timeoff'] if 'paid_timeoff' in row else False,
                        'classification': reason_result['label'],
                        'similarity_score': reason_result.get('similarity', 0),
                        'day_info': day_label
                    },
                    'display': 'block'
                })

        return processed_leaves

# Cache d·ªØ li·ªáu ƒë·ªÉ tr√°nh g·ªçi API li√™n t·ª•c
@st.cache_data(ttl=300)  # Cache 5 ph√∫t
def load_timeoff_data():
    """Load d·ªØ li·ªáu timeoff v·ªõi caching"""
    # L·∫•y tokens t·ª´ environment variables
    timeoff_token = os.getenv('TIMEOFF_TOKEN')
    account_token = os.getenv('ACCOUNT_TOKEN')
    
    processor = TimeoffProcessor(timeoff_token, account_token)
    
    try:
        api_data = processor.get_base_timeoff_data()
        df = processor.extract_timeoff_to_dataframe(api_data)
        return df, processor
    except Exception as e:
        st.error(f"L·ªói khi t·∫£i d·ªØ li·ªáu: {e}")
        return pd.DataFrame(), None

def get_state_info():
    """Tr·∫£ v·ªÅ th√¥ng tin v·ªÅ c√°c tr·∫°ng th√°i v√† m√†u s·∫Øc"""
    return {
        'approved': {'color': '#28a745', 'icon': '‚úÖ', 'label': 'ƒê√£ duy·ªát'},
        'pending': {'color': '#ffc107', 'icon': '‚è≥', 'label': 'Ch·ªù duy·ªát'},
        'rejected': {'color': '#dc3545', 'icon': '‚ùå', 'label': 'T·ª´ ch·ªëi'},
        'cancelled': {'color': '#6c757d', 'icon': '‚èπÔ∏è', 'label': 'ƒê√£ h·ªßy'},
        'draft': {'color': '#17a2b8', 'icon': 'üìù', 'label': 'Nh√°p'}
    }

def get_metatype_info():
    """Tr·∫£ v·ªÅ th√¥ng tin v·ªÅ c√°c lo·∫°i ngh·ªâ ph√©p v√† m√†u s·∫Øc"""
    return {
        'annual': {'color': '#28a745', 'icon': 'üèñÔ∏è', 'label': 'Ngh·ªâ ph√©p nƒÉm'},
        'sick': {'color': '#fd7e14', 'icon': 'ü§í', 'label': 'Ngh·ªâ ·ªëm'},
        'unpaid': {'color': '#dc3545', 'icon': 'üí∏', 'label': 'Ngh·ªâ kh√¥ng l∆∞∆°ng'},
        'personal': {'color': '#6f42c1', 'icon': 'üë§', 'label': 'Ngh·ªâ c√° nh√¢n'},
        'outside': {'color': '#20c997', 'icon': 'üè¢', 'label': 'C√¥ng t√°c ngo√†i'},
        'maternity': {'color': '#e83e8c', 'icon': 'üë∂', 'label': 'Ngh·ªâ thai s·∫£n'},
        'wedding': {'color': '#fd7e14', 'icon': 'üíí', 'label': 'Ngh·ªâ c∆∞·ªõi'},
        'funeral': {'color': '#6c757d', 'icon': 'üïäÔ∏è', 'label': 'Ngh·ªâ tang'}
    }

def convert_df_to_calendar_events(df, processor, use_reason_classification=True):
    """
    UPGRADED VERSION: Chuy·ªÉn DataFrame th√†nh format events cho calendar 
    v·ªõi x·ª≠ l√Ω ngh·ªâ nhi·ªÅu ng√†y v√† t·∫°o nhi·ªÅu events cho m·ªói bu·ªïi
    """
    events = []
    
    if df.empty or processor is None:
        return events
    
    # Kh·ªüi t·∫°o classifier
    classifier = ReasonClassifier() if use_reason_classification else None
    
    if not use_reason_classification:
        # Fallback v·ªÅ logic c≈© n·∫øu kh√¥ng d√πng AI
        state_info = get_state_info()
        metatype_info = get_metatype_info()
        
        for _, row in df.iterrows():
            if pd.notna(row['start_date']) and pd.notna(row['end_date']):
                # Logic c≈©...
                if row['state'] == 'approved':
                    color = metatype_info.get(row['metatype'], {}).get('color', '#28a745')
                    icon = metatype_info.get(row['metatype'], {}).get('icon', 'üìÖ')
                else:
                    color = state_info.get(row['state'], {}).get('color', '#007bff')
                    icon = state_info.get(row['state'], {}).get('icon', 'üìÖ')
                
                title = f"{icon} {row['employee_name']}"
                if row['ly_do'] and row['ly_do'] != '':
                    reason_short = row['ly_do'][:25] + "..." if len(row['ly_do']) > 25 else row['ly_do']
                    title += f" - {reason_short}"
                
                events.append({
                    "title": title,
                    "start": row['start_date'].strftime('%Y-%m-%d'),
                    "end": (row['end_date'] + timedelta(days=1)).strftime('%Y-%m-%d'),
                    "color": color,
                    "allDay": True
                })
    else:
        # S·ª≠ d·ª•ng logic m·ªõi v·ªõi AI classification
        for _, row in df.iterrows():
            processed_events = processor.process_and_structure_timeoff(row, classifier)
            if processed_events:
                events.extend(processed_events)
    
    return events

def display_calendar_legend(show_reason_classification=True):
    """Hi·ªÉn th·ªã ch√∫ th√≠ch m√†u s·∫Øc cho calendar"""
    st.markdown("#### üìã Ch√∫ th√≠ch")
    
    if show_reason_classification:
        st.markdown("**üéØ Ph√¢n lo·∫°i theo l√Ω do (AI Classification):**")
        
        reason_classifier = ReasonClassifier()
        
        col1, col2 = st.columns(2)
        
        categories = list(reason_classifier.categories.items())
        categories.append(('other', {
            'color': '#6c757d',
            'icon': 'üìù', 
            'label': 'Kh√°c'
        }))
        
        mid_point = len(categories) // 2 + 1
        
        with col1:
            for category, info in categories[:mid_point]:
                st.markdown(f"<div style='display: flex; align-items: center; margin: 5px 0;'>"
                           f"<div style='width: 20px; height: 20px; background-color: {info['color']}; "
                           f"border-radius: 3px; margin-right: 10px;'></div>"
                           f"<span>{info['icon']} {info['label']}</span></div>", 
                           unsafe_allow_html=True)
        
        with col2:
            for category, info in categories[mid_point:]:
                st.markdown(f"<div style='display: flex; align-items: center; margin: 5px 0;'>"
                           f"<div style='width: 20px; height: 20px; background-color: {info['color']}; "
                           f"border-radius: 3px; margin-right: 10px;'></div>"
                           f"<span>{info['icon']} {info['label']}</span></div>", 
                           unsafe_allow_html=True)
    else:
        st.info("üí° B·∫≠t 'S·ª≠ d·ª•ng AI ph√¢n lo·∫°i l√Ω do' ƒë·ªÉ xem ch√∫ th√≠ch m√†u s·∫Øc th√¥ng minh")

def display_event_details(event_data):
    """Hi·ªÉn th·ªã chi ti·∫øt event khi click - UPGRADED v·ªõi th√¥ng tin ng√†y v√† bu·ªïi"""
    if not event_data:
        return
    
    props = event_data.get('extendedProps', {})
    state_info = get_state_info()
    metatype_info = get_metatype_info()
    
    state = props.get('state', '')
    metatype = props.get('metatype', '')
    state_display = state_info.get(state, {})
    metatype_display = metatype_info.get(metatype, {})
    
    st.markdown("### üìã Chi ti·∫øt y√™u c·∫ßu ngh·ªâ ph√©p")
    
    # Header card
    st.markdown(f"""
    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                padding: 20px; border-radius: 10px; color: white; margin: 10px 0;">
        <h4 style="margin: 0; color: white;">üë§ {props.get('employee', 'N/A')}</h4>
    </div>
    """, unsafe_allow_html=True)
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("**üìÖ Th√¥ng tin th·ªùi gian:**")
        
        is_all_day = event_data.get('allDay', True)
        start_time = event_data.get('start', 'N/A')
        end_time = event_data.get('end', 'N/A')
        
        # Hi·ªÉn th·ªã th√¥ng tin ng√†y v√† bu·ªïi n·∫øu c√≥
        day_info = props.get('day_info', '')
        shift_info = props.get('shift_info', '')
        
        if day_info:
            st.info(f"**üìÜ {day_info}**")
        if shift_info:
            st.success(f"**‚è∞ Bu·ªïi: {shift_info}**")
        
        if is_all_day:
            st.info(f"**T·ª´ ng√†y:** {start_time}\n"
                    f"**ƒê·∫øn ng√†y:** {end_time}\n"
                    f"**S·ªë ng√†y:** {props.get('days', 0)} ng√†y\n"
                    f"**Lo·∫°i:** C·∫£ ng√†y")
        else:
            st.info(f"**Ng√†y:** {start_time.split('T')[0] if 'T' in start_time else start_time}\n"
                    f"**Th·ªùi gian:** {start_time.split('T')[1][:5] if 'T' in start_time else 'N/A'} - {end_time.split('T')[1][:5] if 'T' in end_time else 'N/A'}\n"
                    f"**S·ªë ng√†y:** {props.get('days', 0)} ng√†y\n"
                    f"**Lo·∫°i:** Theo gi·ªù")
        
        buoi_nghi = props.get('buoi_nghi', [])
        if buoi_nghi and isinstance(buoi_nghi, list):
            buoi_nghi_str = ', '.join(buoi_nghi)
            st.success(f"**‚è∞ Bu·ªïi ngh·ªâ:** {buoi_nghi_str}")
        
        st.markdown("**üìä Tr·∫°ng th√°i & Lo·∫°i:**")
        status_color = state_display.get('color', '#007bff')
        metatype_color = metatype_display.get('color', '#007bff')
        
        st.markdown(f"""
        <div style="margin: 10px 0;">
            <span style="background-color: {status_color}; color: white; padding: 5px 10px; 
                         border-radius: 15px; font-size: 14px;">
                {state_display.get('icon', '')} {state_display.get('label', state)}
            </span>
        </div>
        <div style="margin: 10px 0;">
            <span style="background-color: {metatype_color}; color: white; padding: 5px 10px; 
                         border-radius: 15px; font-size: 14px;">
                {metatype_display.get('icon', '')} {metatype_display.get('label', metatype)}
            </span>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("**üìù Th√¥ng tin chi ti·∫øt:**")
        reason = props.get('reason', 'Kh√¥ng c√≥ th√¥ng tin')
        if reason and reason.strip():
            st.success(f"**L√Ω do:** {reason}")
            
            classification = props.get('classification', '')
            similarity_score = props.get('similarity_score', 0)
            if classification and similarity_score > 0:
                st.info(f"**AI Classification:** {classification}")
                st.text(f"ƒê·ªô ch√≠nh x√°c: {similarity_score:.2f}")
        else:
            st.info("**L√Ω do:** Kh√¥ng c√≥ th√¥ng tin")
        
        approver = props.get('approver', 'N/A')
        if approver and approver.strip():
            st.success(f"**Ng∆∞·ªùi duy·ªát:** {approver}")
        
        paid_status = "C√≥ l∆∞∆°ng" if props.get('paid', False) else "Kh√¥ng l∆∞∆°ng"
        st.info(f"**Lo·∫°i:** {paid_status}")
    
    st.markdown("**‚è∞ Th·ªùi gian x·ª≠ l√Ω:**")
    col3, col4 = st.columns(2)
    with col3:
        st.text(f"T·∫°o: {props.get('created_time', 'N/A')}")
    with col4:
        st.text(f"C·∫≠p nh·∫≠t: {props.get('last_update', 'N/A')}")

def display_reason_analysis(df):
    """Hi·ªÉn th·ªã ph√¢n t√≠ch l√Ω do ngh·ªâ ph√©p"""
    st.markdown("### ü§ñ Ph√¢n t√≠ch l√Ω do ngh·ªâ ph√©p (AI Analysis)")
    
    if df.empty or 'ly_do' not in df.columns:
        st.info("Kh√¥ng c√≥ d·ªØ li·ªáu l√Ω do ƒë·ªÉ ph√¢n t√≠ch")
        return
    
    df_with_reason = df[df['ly_do'].notna() & (df['ly_do'].astype(str).str.strip() != '')]
    
    if df_with_reason.empty:
        st.info("Kh√¥ng c√≥ l√Ω do ngh·ªâ ph√©p trong d·ªØ li·ªáu")
        return
    
    classifier = ReasonClassifier()
    reasons_list = df_with_reason['ly_do'].astype(str).tolist()
    distribution = classifier.get_category_distribution(reasons_list)
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        if distribution:
            categories = []
            counts = []
            colors = []
            
            for category, data in distribution.items():
                categories.append(f"{data['icon']} {data['label']}")
                counts.append(data['count'])
                colors.append(data['color'])
            
            fig = px.pie(
                values=counts,
                names=categories,
                title="üéØ Ph√¢n b·ªë l√Ω do ngh·ªâ ph√©p (AI Classification)",
                color_discrete_sequence=colors
            )
            fig.update_traces(textposition='inside', textinfo='percent+label')
            fig.update_layout(showlegend=True, height=400)
            st.plotly_chart(fig, use_container_width=True)
    
    with col2:
        st.markdown("**üìä Th·ªëng k√™ chi ti·∫øt:**")
        
        total_with_reason = len(df_with_reason)
        total_classified = sum(data['count'] for data in distribution.values())
        
        st.metric("T·ªïng s·ªë c√≥ l√Ω do", total_with_reason)
        st.metric("ƒê√£ ph√¢n lo·∫°i", total_classified)
        st.metric("T·ª∑ l·ªá ph√¢n lo·∫°i", f"{total_classified/total_with_reason*100:.1f}%")
        
        sorted_categories = sorted(distribution.items(), key=lambda x: x[1]['count'], reverse=True)
        
        st.markdown("**üèÜ Top categories:**")
        for i, (category, data) in enumerate(sorted_categories[:5]):
            percentage = (data['count'] / total_classified * 100) if total_classified > 0 else 0
            st.markdown(f"**{i+1}.** {data['icon']} {data['label']}: {data['count']} ({percentage:.1f}%)")

def display_buoi_nghi_analysis(df):
    """Hi·ªÉn th·ªã ph√¢n t√≠ch bu·ªïi ngh·ªâ"""
    st.markdown("### ‚è∞ Ph√¢n t√≠ch bu·ªïi ngh·ªâ")
    
    if df.empty or 'buoi_nghi' not in df.columns:
        st.info("Kh√¥ng c√≥ d·ªØ li·ªáu bu·ªïi ngh·ªâ ƒë·ªÉ ph√¢n t√≠ch")
        return
    
    df_with_buoi = df[df['buoi_nghi'].notna() & (df['buoi_nghi'].astype(str) != '[]')]
    
    if df_with_buoi.empty:
        st.info("Kh√¥ng c√≥ d·ªØ li·ªáu bu·ªïi ngh·ªâ")
        return
    
    shift_counts = {}
    shift_combinations = {}
    
    for idx, row in df_with_buoi.iterrows():
        buoi_nghi = row['buoi_nghi']
        if isinstance(buoi_nghi, list) and buoi_nghi:
            for shift in buoi_nghi:
                if shift not in shift_counts:
                    shift_counts[shift] = 0
                shift_counts[shift] += 1
            
            combination_key = ' + '.join(sorted(buoi_nghi))
            if combination_key not in shift_combinations:
                shift_combinations[combination_key] = 0
            shift_combinations[combination_key] += 1
    
    col1, col2 = st.columns(2)
    
    with col1:
        if shift_counts:
            shifts = list(shift_counts.keys())
            counts = list(shift_counts.values())
            
            fig1 = px.bar(
                x=shifts,
                y=counts,
                title="üìä T·∫ßn su·∫•t bu·ªïi ngh·ªâ",
                labels={'x': 'Bu·ªïi', 'y': 'S·ªë l·∫ßn'},
                color=counts,
                color_continuous_scale="Blues"
            )
            fig1.update_layout(height=400, showlegend=False)
            st.plotly_chart(fig1, use_container_width=True)
    
    with col2:
        if shift_combinations:
            combinations = list(shift_combinations.keys())[:10]
            combo_counts = [shift_combinations[combo] for combo in combinations]
            
            fig2 = px.bar(
                x=combo_counts,
                y=combinations,
                orientation='h',
                title="üîÑ Top 10 k·∫øt h·ª£p bu·ªïi ngh·ªâ",
                labels={'x': 'S·ªë l·∫ßn', 'y': 'K·∫øt h·ª£p'},
                color=combo_counts,
                color_continuous_scale="Viridis"
            )
            fig2.update_layout(height=400, showlegend=False)
            st.plotly_chart(fig2, use_container_width=True)
    
    st.markdown("### üìà Th·ªëng k√™ bu·ªïi ngh·ªâ:")
    
    col3, col4, col5 = st.columns(3)
    
    with col3:
        total_shifts = sum(shift_counts.values())
        st.metric("T·ªïng s·ªë bu·ªïi ngh·ªâ", total_shifts)
    
    with col4:
        unique_shifts = len(shift_counts)
        st.metric("S·ªë lo·∫°i bu·ªïi kh√°c nhau", unique_shifts)
    
    with col5:
        avg_shifts_per_request = total_shifts / len(df_with_buoi)
        st.metric("Trung b√¨nh bu·ªïi/y√™u c·∫ßu", f"{avg_shifts_per_request:.1f}")

def main():
    """Main dashboard - UPGRADED VERSION"""
    
    # Custom CSS
    st.markdown("""
    <style>
    .main-header {
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        padding: 2rem;
        border-radius: 10px;
        color: white;
        text-align: center;
        margin-bottom: 2rem;
    }
    
    .metric-card {
        background: white;
        padding: 1rem;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        border-left: 4px solid #667eea;
    }
    
    .calendar-container {
        background: white;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .upgrade-badge {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        display: inline-block;
        margin-left: 10px;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # Header
    st.markdown("""
    <div class="main-header">
        <h1>üèñÔ∏è Time Off Management Dashboard <span class="upgrade-badge">‚ú® UPGRADED</span></h1>
        <p>Qu·∫£n l√Ω v√† theo d√µi y√™u c·∫ßu ngh·ªâ ph√©p v·ªõi AI Classification & Multi-day Support</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Load data
    with st.spinner("üîÑ ƒêang t·∫£i d·ªØ li·ªáu..."):
        df, processor = load_timeoff_data()
    
    if df.empty:
        st.error("‚ùå Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu timeoff")
        return
    
    # Sidebar filters
    st.sidebar.markdown("## üîç B·ªô l·ªçc d·ªØ li·ªáu")
    
    use_ai_classification = st.sidebar.checkbox("ü§ñ S·ª≠ d·ª•ng AI ph√¢n lo·∫°i l√Ω do", value=True)
    
    # Date range filter
    if not df.empty and 'start_date' in df.columns:
        min_date = df['start_date'].min().date() if pd.notna(df['start_date'].min()) else datetime.now().date()
        max_date = df['start_date'].max().date() if pd.notna(df['start_date'].max()) else datetime.now().date()
        
        date_range = st.sidebar.date_input(
            "üìÖ Kho·∫£ng th·ªùi gian",
            value=(min_date, max_date),
            min_value=min_date,
            max_value=max_date
        )
    
    # Employee filter
    employees = ['T·∫•t c·∫£'] + sorted(df['employee_name'].unique().tolist())
    selected_employees = st.sidebar.multiselect(
        "üë• Nh√¢n vi√™n", 
        employees, 
        default=['T·∫•t c·∫£']
    )
    
    # State filter
    state_info = get_state_info()
    state_options = ['T·∫•t c·∫£'] + [f"{info['icon']} {info['label']}" for state, info in state_info.items()]
    selected_states_display = st.sidebar.multiselect(
        "üìä Tr·∫°ng th√°i",
        state_options,
        default=['T·∫•t c·∫£']
    )
    
    selected_states = []
    if 'T·∫•t c·∫£' not in selected_states_display:
        for display in selected_states_display:
            for state, info in state_info.items():
                if f"{info['icon']} {info['label']}" == display:
                    selected_states.append(state)
    else:
        selected_states = ['T·∫•t c·∫£']
    
    # Metatype filter
    metatype_info = get_metatype_info()
    metatype_options = ['T·∫•t c·∫£'] + [f"{info['icon']} {info['label']}" for meta, info in metatype_info.items()]
    selected_metatypes_display = st.sidebar.multiselect(
        "üìã Lo·∫°i ngh·ªâ ph√©p",
        metatype_options,
        default=['T·∫•t c·∫£']
    )
    
    selected_metatypes = []
    if 'T·∫•t c·∫£' not in selected_metatypes_display:
        for display in selected_metatypes_display:
            for metatype, info in metatype_info.items():
                if f"{info['icon']} {info['label']}" == display:
                    selected_metatypes.append(metatype)
    else:
        selected_metatypes = ['T·∫•t c·∫£']
    
    # Apply filters
    filtered_df = df.copy()
    
    if len(date_range) == 2:
        filtered_df = filtered_df[
            (filtered_df['start_date'].dt.date >= date_range[0]) & 
            (filtered_df['start_date'].dt.date <= date_range[1])
        ]
    
    if 'T·∫•t c·∫£' not in selected_employees:
        filtered_df = filtered_df[filtered_df['employee_name'].isin(selected_employees)]
    
    if 'T·∫•t c·∫£' not in selected_states:
        filtered_df = filtered_df[filtered_df['state'].isin(selected_states)]
    
    if 'T·∫•t c·∫£' not in selected_metatypes:
        filtered_df = filtered_df[filtered_df['metatype'].isin(selected_metatypes)]
    
    # Summary metrics
    st.markdown("### üìä T·ªïng quan")
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(
            label="üìã T·ªïng s·ªë y√™u c·∫ßu", 
            value=len(filtered_df),
            delta=f"{len(filtered_df)} requests"
        )
    
    with col2:
        approved_count = len(filtered_df[filtered_df['state'] == 'approved'])
        approval_rate = (approved_count / len(filtered_df) * 100) if len(filtered_df) > 0 else 0
        st.metric(
            label="‚úÖ ƒê√£ duy·ªát", 
            value=approved_count,
            delta=f"{approval_rate:.1f}% t·ª∑ l·ªá duy·ªát"
        )
    
    with col3:
        pending_count = len(filtered_df[filtered_df['state'] == 'pending'])
        st.metric(
            label="‚è≥ Ch·ªù duy·ªát", 
            value=pending_count,
            delta=f"{pending_count} pending"
        )
    
    with col4:
        total_days = filtered_df['total_leave_days'].sum()
        avg_days = total_days / len(filtered_df) if len(filtered_df) > 0 else 0
        st.metric(
            label="üìÖ T·ªïng s·ªë ng√†y ngh·ªâ", 
            value=f"{total_days:.1f}",
            delta=f"{avg_days:.1f} ng√†y/y√™u c·∫ßu"
        )
    
    # Tabs
    tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs([
        "üìÖ Calendar View", 
        "üìä Analytics", 
        "ü§ñ AI Analysis",
        "‚è∞ Shift Analysis",
        "üìã Data Table", 
        "‚öôÔ∏è Settings"
    ])
    
    with tab1:
        st.markdown("### üìÖ L·ªãch Time Off")
        st.info("‚ú® UPGRADED: H·ªó tr·ª£ hi·ªÉn th·ªã ngh·ªâ nhi·ªÅu ng√†y, t·∫°o nhi·ªÅu events cho m·ªói bu·ªïi ngh·ªâ")
        
        col1, col2 = st.columns([3, 1])
        
        with col1:
            mode_options = {
                "dayGridMonth": "üìÖ Th√°ng",
                "dayGridWeek": "üìÖ Tu·∫ßn", 
                "timeGridWeek": "‚è∞ Tu·∫ßn (gi·ªù)",
                "listMonth": "üìã Danh s√°ch th√°ng"
            }
            
            selected_mode_display = st.selectbox(
                "Ch·∫ø ƒë·ªô xem:",
                list(mode_options.values()),
                index=2  # Default to timeGridWeek ƒë·ªÉ th·∫•y r√µ events theo gi·ªù
            )
            
            mode = [k for k, v in mode_options.items() if v == selected_mode_display][0]
        
        with col2:
            st.markdown("**üé® T√πy ch·ªçn hi·ªÉn th·ªã**")
            show_legend = st.checkbox("Hi·ªÉn th·ªã ch√∫ th√≠ch", value=True)
            show_weekend = st.checkbox("Hi·ªÉn th·ªã cu·ªëi tu·∫ßn", value=True)
        
        # Convert data to events
        events = convert_df_to_calendar_events(filtered_df, processor, use_reason_classification=use_ai_classification)
        
        # Calendar options
        calendar_options = {
            "editable": False,
            "navLinks": True,
            "selectable": False,
            "dayMaxEvents": 5,
            "moreLinkClick": "popover",
            "eventDisplay": "block",
            "displayEventTime": True,
            "weekends": show_weekend,
            "headerToolbar": {
                "left": "today prev,next",
                "center": "title", 
                "right": "dayGridMonth,dayGridWeek,timeGridWeek,listMonth"
            },
            "initialView": mode,
            "height": 700,
            "locale": "vi",
            "slotMinTime": "06:00:00",
            "slotMaxTime": "20:00:00",
            "slotDuration": "00:30:00",
            "expandRows": True
        }
        
        # Custom CSS
        custom_css = """
        <style>
        .fc-event {
            font-size: 12px;
            border-radius: 4px;
            padding: 2px 4px;
            margin: 1px 0;
        }
        .fc-timegrid-event {
            border-left-width: 3px !important;
        }
        </style>
        """
        
        st.markdown(custom_css, unsafe_allow_html=True)
        
        # Display calendar
        if events:
            st.markdown(f"**üìä T·ªïng s·ªë events hi·ªÉn th·ªã: {len(events)}**")
            st.markdown('<div class="calendar-container">', unsafe_allow_html=True)
            
            calendar_state = calendar(
                events=events,
                options=calendar_options,
                custom_css=custom_css,
                key="timeoff_calendar_upgraded"
            )
            
            st.markdown('</div>', unsafe_allow_html=True)
            
            if calendar_state.get("eventClick"):
                event_data = calendar_state["eventClick"]["event"]
                display_event_details(event_data)
                
        else:
            st.info("üìÖ Kh√¥ng c√≥ d·ªØ li·ªáu time off trong kho·∫£ng th·ªùi gian ƒë∆∞·ª£c ch·ªçn")
        
        if show_legend:
            display_calendar_legend(show_reason_classification=use_ai_classification)
    
    with tab2:
        st.subheader("üìä Ph√¢n t√≠ch d·ªØ li·ªáu")
        
        if not filtered_df.empty:
            col1, col2 = st.columns(2)
            
            with col1:
                state_counts = filtered_df['state'].value_counts()
                colors = [get_state_info().get(state, {}).get('color', '#007bff') for state in state_counts.index]
                
                fig1 = px.pie(
                    values=state_counts.values, 
                    names=[get_state_info().get(state, {}).get('label', state) for state in state_counts.index],
                    title="üéØ Ph√¢n b·ªë theo tr·∫°ng th√°i",
                    color_discrete_sequence=colors
                )
                fig1.update_traces(textposition='inside', textinfo='percent+label')
                st.plotly_chart(fig1, use_container_width=True)
                
                top_employees = filtered_df['employee_name'].value_counts().head(10)
                fig3 = px.bar(
                    x=top_employees.values,
                    y=top_employees.index,
                    orientation='h',
                    title="üë• Top 10 nh√¢n vi√™n",
                    color=top_employees.values,
                    color_continuous_scale="viridis"
                )
                st.plotly_chart(fig3, use_container_width=True)
            
            with col2:
                metatype_counts = filtered_df['metatype'].value_counts()
                colors = [get_metatype_info().get(meta, {}).get('color', '#007bff') for meta in metatype_counts.index]
                
                fig2 = px.bar(
                    x=[get_metatype_info().get(meta, {}).get('label', meta) for meta in metatype_counts.index],
                    y=metatype_counts.values,
                    title="üìã Ph√¢n b·ªë theo lo·∫°i",
                    color=metatype_counts.values,
                    color_discrete_sequence=colors
                )
                st.plotly_chart(fig2, use_container_width=True)
                
                if 'start_date' in filtered_df.columns:
                    monthly_data = filtered_df.groupby(
                        filtered_df['start_date'].dt.to_period('M')
                    ).size().reset_index()
                    monthly_data.columns = ['Th√°ng', 'S·ªë y√™u c·∫ßu']
                    monthly_data['Th√°ng'] = monthly_data['Th√°ng'].astype(str)
                    
                    fig4 = px.line(
                        monthly_data, 
                        x='Th√°ng', 
                        y='S·ªë y√™u c·∫ßu',
                        title="üìà Xu h∆∞·ªõng theo th·ªùi gian",
                        markers=True
                    )
                    st.plotly_chart(fig4, use_container_width=True)
    
    with tab3:
        display_reason_analysis(filtered_df)
    
    with tab4:
        display_buoi_nghi_analysis(filtered_df)
    
    with tab5:
        st.subheader("üìã B·∫£ng d·ªØ li·ªáu")
        
        col1, col2, col3 = st.columns([2, 1, 1])
        with col2:
            show_all_columns = st.checkbox("Hi·ªÉn th·ªã t·∫•t c·∫£ c·ªôt", False)
        with col3:
            items_per_page = st.selectbox("S·ªë d√≤ng/trang", [10, 25, 50, 100], index=1)
        
        if not filtered_df.empty:
            if show_all_columns:
                display_df = filtered_df
            else:
                important_cols = [
                    'employee_name', 'state', 'metatype', 'start_date', 'end_date', 
                    'total_leave_days', 'buoi_nghi', 'ly_do', 'final_approver'
                ]
                available_cols = [col for col in important_cols if col in filtered_df.columns]
                display_df = filtered_df[available_cols]
            
            if 'start_date' in display_df.columns:
                display_df['start_date'] = pd.to_datetime(display_df['start_date']).dt.strftime('%Y-%m-%d')
            if 'end_date' in display_df.columns:
                display_df['end_date'] = pd.to_datetime(display_df['end_date']).dt.strftime('%Y-%m-%d')
            
            if 'buoi_nghi' in display_df.columns:
                display_df_copy = display_df.copy()
                display_df_copy['buoi_nghi'] = display_df_copy['buoi_nghi'].apply(
                    lambda x: ', '.join(x) if isinstance(x, list) and x else 'N/A'
                )
                display_df = display_df_copy
            
            st.dataframe(display_df, use_container_width=True, hide_index=True)
            
            st.markdown("### üì• T·∫£i xu·ªëng d·ªØ li·ªáu")
            col1, col2 = st.columns(2)
            
            with col1:
                csv = filtered_df.to_csv(index=False, encoding='utf-8-sig')
                st.download_button(
                    label="üì• T·∫£i xu·ªëng CSV",
                    data=csv,
                    file_name=f"timeoff_data_{datetime.now().strftime('%Y%m%d')}.csv",
                    mime="text/csv",
                    type="primary"
                )
            
            with col2:
                json_data = filtered_df.to_json(orient='records', date_format='iso', force_ascii=False)
                st.download_button(
                    label="üì• T·∫£i xu·ªëng JSON",
                    data=json_data,
                    file_name=f"timeoff_data_{datetime.now().strftime('%Y%m%d')}.json",
                    mime="application/json"
                )
    
    with tab6:
        st.subheader("‚öôÔ∏è C√†i ƒë·∫∑t h·ªá th·ªëng")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("#### üìà Th√¥ng tin h·ªá th·ªëng")
            st.metric("T·ªïng s·ªë records", len(df))
            st.metric("S·ªë nh√¢n vi√™n", df['employee_name'].nunique())
            st.metric("Records sau l·ªçc", len(filtered_df))
            
            # Upgrade features
            st.markdown("#### ‚ú® T√≠nh nƒÉng m·ªõi")
            st.success("‚úÖ X·ª≠ l√Ω timezone ch√≠nh x√°c (pytz)")
            st.success("‚úÖ H·ªó tr·ª£ ngh·ªâ nhi·ªÅu ng√†y")
            st.success("‚úÖ T·∫°o nhi·ªÅu events cho m·ªói bu·ªïi")
            st.success("‚úÖ Hi·ªÉn th·ªã chi ti·∫øt ng√†y v√† bu·ªïi")
        
        with col2:
            st.markdown("#### üîß C√¥ng c·ª• qu·∫£n l√Ω")
            
            if st.button("üîÑ L√†m m·ªõi d·ªØ li·ªáu", type="primary", use_container_width=True):
                st.cache_data.clear()
                st.rerun()
            
            st.markdown("---")
            
            full_csv = df.to_csv(index=False, encoding='utf-8-sig')
            st.download_button(
                label="üì• T·∫£i xu·ªëng to√†n b·ªô d·ªØ li·ªáu",
                data=full_csv,
                file_name=f"full_timeoff_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                mime="text/csv",
                use_container_width=True
            )
            
            st.markdown("---")
            st.markdown("**‚ö° Tr·∫°ng th√°i:**")
            st.success("‚úÖ API Connection: Active")
            st.success("‚úÖ Data Cache: Active")
            st.success("‚úÖ Timezone: Asia/Ho_Chi_Minh")
            st.success("‚úÖ Multi-day Support: Enabled")
            st.info(f"üïí Last Update: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

if __name__ == "__main__":
    main()
